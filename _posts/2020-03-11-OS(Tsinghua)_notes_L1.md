---
title:      "2020春季OS(Tsinghua) Notes L1"
date:       2020-03-11 08:00:00
categories: Learning_Notes
excerpt_separator: <!--more-->
latex: true
tags:
    - OS
    - Lecture notes
---
## <center>操作系统概述</center>
<!--more-->

## Definition
* 操作系统没有公认的精确定义  
* 操作系统是一个控制程序
    - 一个系统软件
    - 控制程序执行过程，防止错误
    - 执行用户程序，给程序提供服务
    - 方便用户使用计算机系统
* 操作系统是一个资源管理程序
    - 应用程序与硬件之间的中间层
    - 管理各种软硬件资源
    - 提供访问软硬件资源的高效手段
    - 解决访问冲突，确保公平使用

***
## OS抽象
![f1]({{site.baseurl}}/assets/images/images_of_blog/OS_notes_L1_f1.png)
> * OS负责CPU资源的管理，CPU提供计算功能，OS抽象出数据结构->进程控制块，也就是进程，进程描述一个程序如何被加载到计算机系统中，OS如何给它分配它所需要的资源，占用CPU执行，同时负责如果多个程序在执行时，它们的暂停和恢复
> * 磁盘上的数据在OS中被抽象成文件，文件是操作系统中访问的$\color{red}{基本单位}$，去访问某个文件时需要知道文件的位置，往文件里写数据时需要知道文件存到哪，这是OS要解决的问题
> * 对于内存，是临时性存数据的地方，被抽象成地址空间，多个应用程序交替执行时，就会有“我到底把哪块空间分配给哪个进程来执行”

***
## OS内核特征
* 并发：计算机系统中同时存在多个运行程序
* 共享：程序间“同时”访问互斥共享各种资源
* 虚拟：每个程序“独占”一个完整的计算机
* 异步：服务的完成时间不确定，也可能失败

***
## 从OS角度看计算机系统
### 程序调用的特征
* 好处：  
    1. 执行很快；
    2. 灵活-易于传递和返回复杂数据类型；
    3. 程序员熟悉的机制

* 坏处：  
    * 应用程序不可靠，可能有恶意，有崩溃的风险

### 隔离
若有多个应用程序在一个CPU上交替运行，隔离就应该是要做的主要的事情  
* $\color{red}{目的：}$为整个系统的可用性、可靠性、安全提供保障
* 运行的程序通常是隔离的单元
* $\color{red}{目标：}$  
    1. 防止程序X破坏或监视程序Y
        * 如读/写内存，使用100%的CPU，更改文件描述符
    2. 防止进程干扰操作系统
    3. 防止恶意程序、病毒、木马和BUG
        * 错误的过程可能会试图欺骗硬件或内核

* $\color{red}{主要方法：}$   

    1. 地址空间    
        * 一个程序仅寻址其自己的内存
        * 每个程序若无许可，则无法访问不属于自己的内存
    > $\color{red}{通过在内存中建立页表，查询页表找到对应的物理位置}$    
    > ![f2]({{site.baseurl}}/assets/images/images_of_blog/OS_notes_L1_f2.png)
    > $\color{red}{为了加快查询速度，建立快表，相当于缓存}$  
    > ![f3]({{site.baseurl}}/assets/images/images_of_blog/OS_notes_L1_f3.png)
    2. CPU硬件中的特权模式/中断机制
        * 防止应用程序访问设备和敏感的CPU寄存器
        * 如地址空间配置寄存器
        * 如打断一直占用CPU的应用程序
    > $\color{red}{Kernel\; Mode\; VS\; User\; Mode}$ 
    > - Kernel Mode 可以执行User Mode 无法执行的特权操作
    >   - 访问外设
    >   - 配置地址空间（虚拟内存）
    >   - 读/写特殊系统级寄存器
    > - OS kernel运行在Kernel Mode,应用程序运行在User Mode
    > - 每个重要的微处理器都有类似的用户/内核模式标志    
    > 
    > $\color{red}{中断机制}$  
    > * CPU硬件支持中断/异常的处理  
    > * 中断是异步（因为硬件中断不是由任何一条专门的CPU指令造成）发生，是来自处理器外部的I/O设备的信号的结果。
    > * 硬件中断的异常处理程序——中断处理程序（interrupt handle）
    >   * I/O设备通过向处理器芯片的一个引脚发信号，并将异常号放到系统总线上，以触发中断；
    >   * 在当前指令执行完后，处理器从系统总线读取异常号，保存现场，切换到Kernel Mode；
    >   * 调用中断处理程序，当中断处理程序完成后，它将控制返回给下一条本来要执行的指令
    > * Timer可以稳定定时地产生中断
    >   * 防止应用程序死占着CPU不放
    >   * 让OS kernel能周期性地进行资源管理